
<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
Â  <title>Superking Trinity</title>
Â  <style>
Â  Â  body { 
        background: #111; 
        color: #eee; 
        font-family: sans-serif; 
        text-align: center; 
        padding: 20px; 
    }
Â  Â  canvas { 
        background: #222; 
        display: block; 
        margin: 20px auto; 
        border: 2px solid #0f0; 
    }
Â  Â  /* Top Board/Log Styles */
Â  Â  #log, #position, #verseDisplay { 
        margin: 20px auto; 
        font-size: 18px; 
        white-space: pre-line; 
        text-align: left; 
        max-width: 420px; 
    }
Â  Â  button, input { 
        margin: 8px; 
        padding: 10px 20px; 
        font-size: 16px; 
    }
    /* Separate styles for FEN inputs to prevent conflict */
    #topFenInput {
        width: 90%;
        max-width: 400px;
    }
    #fenInput { /* TARGETED BY THE NEW LOGIC (aifen1) */
        width: 100%;
        max-width: 600px;
        box-sizing: border-box;
    }
Â  Â  #verseDisplay { 
        color: #0f0; 
        font-size: 20px; 
        border-bottom: 2px solid #0f0;
        padding-bottom: 10px;
    }
    /* Bottom AI Interface Styles */
    .section {
        margin: 20px auto;
        padding: 10px;
        border: 1px solid #333;
        border-radius: 8px;
        max-width: 800px;
        text-align: left;
    }
    /* Add a divider between the two main components */
    #interface-divider {
        margin: 50px auto;
        height: 4px;
        background: #0f0;
        width: 90%;
        max-width: 800px;
    }
Â  </style>
Â  <link rel="stylesheet" href="styles.css"> </head>
<body>

Â  <h1><img src="data:image/webp;base64,UklGRiYFAABXRUJQVlA4IBoFAACQFgCdASpAAEAAPpE4mEiloyIhLBqsALASCWQAvj/3DDF3AVvi4JG3a52zTXqAd2ifE56gkCdwWoj8g+9P7X+ucRd/f9z7OQwLvNrKfdHsAfzH+0/9H1Ks7j1l7B3SgYfzKcJfLLimgD6qzLvEc2r1XgmMgX9lSTPKM+4NahCNjnTapBlSDAfNg2sW+thPJs9fbHoFOnw+k6Xbwfs0An8EemtxsP9TlJQU/FlmeRNefRP+oPE4WT/Ep9o4R2AA/vuzCQGz3MIJylDZjZf29QkIkBn3/ouhimCStse8h/ahKJ3uhAoFY8yKXmNW0NKAdD4R78bSkKyn8EHYY+KP405z4GSSQr1vI4fYfWVGFHntkTJdgUiYyN/XSZvcvMYuEe2z6/yC0TlhAt75f/Whya7z9lBfnHaIOsrw+YNVzITjpBoYerhE+E58PWeKwzrTX84hTm1+3S+BTmIbceQjAgEh08ps7jOaPOI/DQXLc642Yge+utYx5MKzT4+iReNcRepbLz68sxZKN1x/Hxft7aJTDAjuEDsJU9+ndfhq3nFOUUAdDyHirJePHo7u/wr5YMujlV/ceBXGQ/bnfzF6bc73TAqi/fHE53QbYhvsxfQpwZ/ic4JA8g1Dsq7n34ZhMVNvu6/Zv5Sr1VketJ51TEgnVaANzDnFhMmDEAX7s82gpRJE1mg+8gM4r/cjxi2tWsP8w2Y3oRg3mIU2aV67HxEKWgSroMCsFvnHfXPfIIKFjrILlnOQ+E0QgvEDYDEM6Ca6Bs8DQrAW7sn7tIqHy2ScgZ+nm4vjRR5K8t3eV4T3Rx13lPqqFcJDvV7Hlz2/Mk+kZaFxdYp32Kc+c+2RB7ngjfttMXJ5aj7Mqx/3IDgwWgRW34nzReEFbr/x7sqhmtx0jh8uGzsMyxPXzURsPZbFtKkEGzETsGlOp7hSMi9XMifx7sWUtXc+Fxd2HNEoQYBGw0p8aJYI3Gqsswn+bILicd5OjpGfVXI5qpbBS5rtkKxtbsRfv31166hsvrJCuETHHW84k+FMDsm+KagtWS/kiQx2xRIr64/akHMmQnf1W02mzUueoK7ooAp0GBdMssCTw180Y1cMqrIRWIimYbMl/40F+VH0a5Nex6w1kJt+jUNL/kffUxCHhuRDLmwppti9Gkxi27Exk2vpe5bOJsqvRB0KdOf+3qd4OBcDzaPC9/hws3iMRvJfyEUOxlvrcDsCvY5T9OAZpEciI3AO+kxxWD7Tb7HBi4OggU3+YlkqPTgKBvlYNeHmvnGMvTXT6hOLCs2mwE6xaGUBp1+n9QdtKBY7x052sKKKtHseqCgIRn7qWKI9u93thPjqYWmtjcponi19Vwt5Jcs5LVXoWLNnRaycVv8CLmMOg/7/sqT8UjquMXYRSDl2+Ff/V86LiBb5rEdM1qkKnNxZSlIRa0J6sKV9YHeRGVWK1O9IrQMLgMRhrqqAfdSoEbvzifVWPmlVOtI3xn0AsP3mMufU/5KWDiPwZGOiof9ZU6KvmUS88K3ZfJwJCILq5LwybmBdMQ/tYIlrJw49t0ARIJ1IFid2c0sXrOXo4CkSjTmXgOV1O8gErnAtfldvDV5lsNnjZhDm4/IZy0M1q9GTXVUFGrI3iAh0f6GUY6HNZTlB4YrCc5E6x99RzCBF0tdLwbrmhNBtdHtG3pUoL0Gkk3tp+JVY6XIiRvNrwdHdU6pVIXbPfYRaTvpXr25EcIxJRv1Xqxp9wc1OV4El9AAA" alt="White Superking" style="width:64px;height:64px;" /> <img src="data:image/webp;base64,UklGRlIFAABXRUJQVlA4IEYFAABQFwCdASpAAEAAPpE2lkgloqIhLhtriLASCWQAv2v3DRF8gkvw4G+3yu4CBItBvxfA9iL9jf53y77wb/J7N2V9j9+g/lfQX6waxh457AH8t/s//S/svsJZzXqb2EOj76I/67M8RJmOASMkPvr3PSkQijdXpu/BbrsbsDcEFHg0zWoQmgvZzitswYEk9RjRXt+oyp/W+AEvIVVok4FHa6P1PrQDjGz30B2xg9K20E0M859hQkLEFTfaojzv76BaQvrifwAA/v9jgbdMqsLoFSPRmrekX90tSn3FtWRfxdhBctt7Gon5eT0koDT3jUnmLkBOdyaBG7fmjoIwHpWWLyjknwAgvnrCEymw+0WbQHBvV0f0CU+EiWc10f38MU6PIiKXO2TyoLYBKpB1QGuSfuHq6gP+icw3azYPf67QW3IKU+DeM+rI7eOm1W+tz3q5QlsIdzpTTHH9BGNW+7O1V6/9VyeqU+WvPOcTzATZ11b0phB824f6rCHVjme08ZQcnzR+CLu3wmwvwErMolQBCDwJoL/Vngx8+HR8Q64JmtDs3MAccZfjD6r3EjizW0K1sszj8J9K2dhhVLQZIJzWOevUuU0qvdxhzq8HrQLRQrMQQpHa7RtRMyawJfmioVEzYHDcZxS+NPK94NPf7MUuKWcrGOgwI7nfmt7sVOAkxDyXy14MqUOSd+qS+ibNzyMIB8TAzwo6r/NkseheQLNAJJ2ZNlxCORcnr6MlHwdg6U5VR7kpH4HBk5Epup2DieIdvoJYbD7AhyaeeOG0scPHODtm84wAC9ixwaEzkOd0ZZX3nl5hxOXpuTY3MauikMkYVhNK4SxQQG/O+ymGXATv6Q17tZn5qqevcWCJYySeUpYZ8VETxnPP/UfdiTJPeF98dzsy7piq0Y/NsMqpg+jz1wWtrMolQExLlLuWREAY0ENvtG+lCQ7BXgVujRzcHcnQAaUriebzBZEGdGLN+5kD37JHTVgdCiV+9YBi2W+CLKwbA999dT0dcgePaGbcD1cNKZZtqt4IQb4MXfINE1sGd3hwCm888tIpM6hYf4v90CG+9fo64+CDAfJ/atZOrHrkCcxOozWY8dDYBh+3hzurXJwIdRMXwb7TikJlucg0EOv7/tuotW7r9oMRoRJ4u3+zRMUg0WsobooKxfl5nfatI/5G3pkAVH9GzzPMa55qIjCu27Ecb9f9/WjMlGJ1d5FbNOHjX840FqvNQgmXlVjS5V+miyamVv5hnBPym44EjxhWQI++b0IZOCM0lFVqx0nKhP1oKKjS7Whq2n7Cxxh8ot11U8tv7fQcbDA80JwhKt7XM4r4NK6Lz8xPOMNfgm9b3cvK+tgF1sULW44CgxEBOrPR25aHxixSv37gYpjf2ThERXQRMZniKYIsSVNL+z4QEdiGl5bGSylpM+etkB/LSS92G6t/SWUlTiQSrUZrWDMuQcKhfj2uHeC7X7T8voQVHkqSFeN3gD4KmjEYge0Akhu8edwX+R2/0GYfJ0DNG2rlq4ILWkefbZMiuz3GG0Veb9akvoVi3iYoRNB2VAlbzzUYrbE4HsO2OirwbRNTi2ezzZSb6etoKc1NE6xY8YE172CHQtGkAy81Lx1jryS5Hi3v3g469ngbuJ1rihl4x7KLAnP+NiNh4MXFiYlI+cPixFlkIaN4goDLepmEzRtUPIomV4hytr+ETCWG3MaGRjTWsMt9wPoegfP8dOXHcerYVc0Gddntkrbm/NVAYQmfpMDK966Y4Dt2mzdF3Xvz3Py0ilT1yrElvhQm951B+HJDSk7nF6w7gAA=" alt="Black Superking" style="width:64px;height:64px;" /> Superking Trinity Chessboard</h1>
Â  <canvas id="boardCanvas" width="480" height="480"></canvas>

Â  Â  <div>
Â  Â  <button onclick="top_finishSuperkingMove()">Finish Move</button>
Â  Â  <button onclick="top_takeBackMove()">Take Back Move</button>
Â  Â  <button onclick="top_showPosition('w')">Show FEN w</button>
Â  Â  <button onclick="top_showPosition('b')">Show FEN b</button>
Â  Â  <button onclick="top_copyFENButtonAction()">Copy Full FEN (w)</button>
    <button onclick="top_copyLog()">Copy Log</button>
Â  </div>

Â  <div>
Â  Â  <input id="topFenInput" placeholder="Paste FEN-style position here for TOP board">
Â  Â  <button onclick="top_loadPosition()">Load Position</button>
Â  </div>

Â  <div id="log">Move Log:</div>
Â  <div id="position">Board Position:</div>
Â  <div id="verseDisplay"></div>

Â  <div id="interface-divider"></div>

Â  Â  <h2>SKT Board Interface</h2>

Â  <div class="section">
Â  Â  <label for="fenInput"><strong>FEN Input (Bottom Interface / aifen1):</strong></label><br>
Â  Â  Â  Â  <textarea id="fenInput" rows="2" cols="80" placeholder="Paste FEN here..."></textarea>
Â  </div>

Â  <div class="section" style="text-align: center;">
Â  Â  <button onclick="bestMove()">Best Move</button>
Â  Â  <button onclick="bestMoveTwoPlies()">Best Move Two Plies</button>
Â  Â  <button onclick="loadFEN()">Load FEN</button>
Â  Â  <button onclick="applyBestMove()">Apply Best Move</button>
Â  Â  <button onclick="aiVsAiFifty(50)">AI vs AI 50 Cycles</button>
Â  Â  <button onclick="transferFinalFEN()">Transfer Final FEN</button>
Â  </div>

Â  <div class="section">
Â  Â  <label for="bestMoveDisplay"><strong>Best Move:</strong></label><br>
Â  Â  <div id="bestMoveDisplay" style="white-space: pre-wrap; min-height: 20px; padding: 10px; background: #f0f0f0; border-radius: 4px; color: #111;"></div>
Â  </div>

Â  <div class="section">
Â  Â  <label for="output"><strong>Path Output:</strong></label><br>
Â  Â  <textarea id="output" rows="10" cols="80" readonly></textarea>
Â  Â  </div>

Â  <div class="section">
Â  Â  <label for="targets"><strong>Targets:</strong></label><br>
Â  Â  <pre id="targets" style="background: #f0f0f0; padding: 10px; border-radius: 4px; color: #111;"></pre>
Â  Â  </div>

Â  <div class="section">
Â  Â  <label for="readBoardOutput"><strong>Read Board FEN:</strong></label><br>
Â  Â  <textarea id="readBoardOutput" rows="2" cols="80"></textarea>
Â  </div>

Â  <div class="section">
Â  Â  <label for="captureMoveOutput"><strong>Captured Move:</strong></label><br>
Â  Â  <textarea id="captureMoveOutput" rows="2" cols="80" readonly></textarea>
Â  Â  <label for="captureFENOutput"><strong>Captured FEN (Before Move):</strong></label><br>
Â  Â  <textarea id="captureFENOutput" rows="2" cols="80" readonly></textarea>
Â  </div>

Â  <div class="section">
Â  Â  <label for="appliedFENOutput"><strong>Applied Move FEN (After Move):</strong></label><br>
Â  Â  <textarea id="appliedFENOutput" rows="2" cols="80" readonly></textarea>
Â  </div>

Â  <div class="section">
Â  Â  <label for="finalFENOutput"><strong>Final FEN After Applying Best Move:</strong></label><br>
Â  Â  <textarea id="finalFENOutput" rows="2" cols="80" readonly></textarea>
Â  </div>

Â  <div class="section" style="text-align: center;">
Â  Â  <strong>Board:</strong><br><br>
Â  Â  <table id="board"></table>
Â  </div>

Â  <div class="section">
Â  Â  <label for="moveLogs"><strong>Move Logs (Cycles):</strong></label><br>
Â  Â  <textarea id="moveLogs" rows="12" cols="80" readonly></textarea>
Â  Â  <div style="text-align: right; margin-top: 5px;">
Â  Â  Â  <button onclick="copyMoveLogs(event)">Copy Move Logs</button>
Â  Â  </div>
Â  </div>

Â  Â  <script>
Â  Â  const canvas = document.getElementById("boardCanvas");
Â  Â  const ctx = canvas.getContext("2d");
Â  Â  const boardSize = 8;
Â  Â  const squareSize = canvas.width / boardSize;

Â  Â  let board = [];
Â  Â  let moveLog = [];
Â  Â  let history = [];
Â  Â  let selected = null;
Â  Â  let superkingPath = [];
Â  Â  let lastMove = null;

Â  Â  const verses = [
Â  Â  Â  "John 3:16 For God so loved the world, that he gave his only begotten Son, that whosoever believeth in him should not perish, but have everlasting life.",
Â  Â  Â  "1 John 5:12 He that hath the Son hath life; and he that hath not the Son of God hath not life.",
Â  Â  Â  "Matthew 28:19 Go ye therefore, and teach all nations, baptizing them in the name of the Father, and of the Son, and of the Holy Ghost."
Â  Â  ];
Â  Â  let verseIndex = 0;

Â  Â  /* --- Piece Mappings & UTILS (unchanged) --- */

Â  Â  // Piece Emojis (Symbol to FEN)
Â  Â  const pieceToFENMap = {
Â  Â  Â  'â™™': 'P', 'â™˜': 'N', 'â™—': 'B', 'â™–': 'R', 'â™•': 'Q', 'â™”': 'K',
Â  Â  Â  'â™Ÿ': 'p', 'â™ž': 'n', 'â™': 'b', 'â™œ': 'r', 'â™›': 'q', 'k': 'k',
Â  Â  Â  'ðŸ‘‘': 'S', // White Superking
Â  Â  Â  'â™š': 's'Â  // Black Superking (MODIFIED)
Â  Â  };

Â  Â  // FEN to Piece Emojis (FEN to Symbol)
Â  Â  const FENtoPieceMap = {
Â  Â  Â  'P': 'â™™', 'N': 'â™˜', 'B': 'â™—', 'R': 'â™–', 'Q': 'â™•', 'K': 'â™”', 'S': 'ðŸ‘‘', // White Superking
Â  Â  Â  'p': 'â™Ÿ', 'n': 'â™ž', 'b': 'â™', 'r': 'â™œ', 'q': 'â™›', 'k': 'â™š', 's': 'â™š' // Black Superking (MODIFIED)
Â  Â  };
Â  Â Â 
Â  Â  // Promotion maps
Â  Â  const whitePromotionMap = { 'Q': 'â™•', 'R': 'â™–', 'B': 'â™—', 'N': 'â™˜' };
Â  Â  const blackPromotionMap = { 'Q': 'â™›', 'R': 'â™œ', 'B': 'â™', 'N': 'â™ž' };

Â  Â  function top_pieceToFEN(piece) {
Â  Â  Â  return pieceToFENMap[piece] || '';
Â  Â  }

Â  Â  function top_FENtoPiece(char) {
Â  Â  Â  return FENtoPieceMap[char] || '';
Â  Â  }

Â  Â  function top_isWhite(piece) {
Â  Â  Â  // Check if the piece is a white symbol (White Superking is 'ðŸ‘‘')
Â  Â  Â  return 'â™™â™˜â™—â™–â™•â™”ðŸ‘‘'.includes(piece);
Â  Â  }
Â  Â Â 
Â  Â  function top_copyBoard(src) {
Â  Â  Â  return src.map(row => row.slice());
Â  Â  }

Â  Â  function top_coordsToAlgebraic(r, c) {
Â  Â  Â  return String.fromCharCode(97 + c) + (8 - r);
Â  Â  }
Â  Â Â 
Â  Â  function top_parseMove(moveStr) {
Â  Â  Â  Â  // Example: "â™™e2e4" â†’ ['â™™', 'e2', 'e4']
Â  Â  Â  Â  if (moveStr.startsWith("S") || moveStr.startsWith("s")) return [moveStr.slice(0, 1), moveStr.slice(1)];
Â  Â  Â  Â  const piece = moveStr[0];
Â  Â  Â  Â  const from = moveStr.slice(1, 3);
Â  Â  Â  Â  const to = moveStr.slice(3, 5);
Â  Â  Â  Â  const promotion = moveStr.length > 5 ? moveStr.slice(5, 6) : '';
Â  Â  Â  Â  return [piece, from, to, promotion];
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Prompts the user for a promotion choice (Q, R, B, N)
Â  Â  Â */
Â  Â  function top_handlePawnPromotion(r, c, piece) {
Â  Â  Â  Â  const isPawn = piece === 'â™™' || piece === 'â™Ÿ';
Â  Â  Â  Â  if (!isPawn) return piece;

Â  Â  Â  Â  const isWhitePiece = top_isWhite(piece);
Â  Â  Â  Â  const lastRank = isWhitePiece ? 0 : boardSize - 1;

Â  Â  Â  Â  if (r === lastRank) {
Â  Â  Â  Â  Â  Â  let choice = prompt("Pawn Promotion! Choose a piece: Q (Queen), R (Rook), B (Bishop), or N (Knight)").toUpperCase();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Validate and convert choice
Â  Â  Â  Â  Â  Â  if (isWhitePiece) {
Â  Â  Â  Â  Â  Â  Â  Â  return whitePromotionMap[choice] || 'â™•'; // Default to Queen
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  return blackPromotionMap[choice] || 'â™›'; // Default to Queen
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return piece;
Â  Â  }

Â  Â  /* --- Piece Movement Logic (unchanged) --- */
Â  Â Â 
Â  Â  function top_getRookMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];Â 

Â  Â  Â  Â  for (const [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  for (let i = 1; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) break;

Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target === '') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc }); // Capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // Blocked
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }

Â  Â  function top_getBishopMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

Â  Â  Â  Â  for (const [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  for (let i = 1; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) break;

Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target === '') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc }); // Capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // Blocked
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }
Â  Â Â 
Â  Â  function top_getQueenMoves(b, r, c) {
Â  Â  Â  Â  return [
Â  Â  Â  Â  Â  Â  ...top_getRookMoves(b, r, c),
Â  Â  Â  Â  Â  Â  ...top_getBishopMoves(b, r, c)
Â  Â  Â  Â  ];
Â  Â  }
Â  Â Â 
Â  Â  function top_getKnightMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  const deltas = [
Â  Â  Â  Â  Â  Â  [-2, -1], [-2, 1], [-1, -2], [-1, 2],
Â  Â  Â  Â  Â  Â  [1, -2], [1, 2], [2, -1], [2, 1]
Â  Â  Â  Â  ];
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (const [dr, dc] of deltas) {
Â  Â  Â  Â  Â  Â  const nr = r + dr;
Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target === '' || top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }
Â  Â Â 
Â  Â  function top_getKingMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  for (let dr = -1; dr <= 1; dr++) {
Â  Â  Â  Â  Â  Â  for (let dc = -1; dc <= 1; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (dr === 0 && dc === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr;
Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target === '' || top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }

Â  Â  function top_getPawnMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const piece = b[r][c];
Â  Â  Â  Â  const isWhitePiece = top_isWhite(piece);
Â  Â  Â  Â  const dir = isWhitePiece ? -1 : 1;
Â  Â  Â  Â  const startRow = isWhitePiece ? 6 : 1;
Â  Â  Â  Â  const finalRank = isWhitePiece ? 0 : boardSize - 1;

Â  Â  Â  Â  // 1. One square forward
Â  Â  Â  Â  const nr1 = r + dir;
Â  Â  Â  Â  if (nr1 >= 0 && nr1 < boardSize && b[nr1][c] === '') {
Â  Â  Â  Â  Â  Â  moves.push({ r: nr1, c: c, promote: nr1 === finalRank });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 2. Two squares forward from starting rank
Â  Â  Â  Â  Â  Â  const nr2 = r + 2 * dir;
Â  Â  Â  Â  Â  Â  if (r === startRow && nr2 >= 0 && nr2 < boardSize && b[nr2][c] === '') {
Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr2, c: c });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // 3. Diagonal captures & Promotion captures
Â  Â  Â  Â  for (let dc of [-1, 1]) {
Â  Â  Â  Â  Â  Â  const nr = r + dir;
Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target !== '' && top_isWhite(target) !== isWhitePiece) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc, capture: true, promote: nr === finalRank });
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 4. En passant (based on the last move)
Â  Â  Â  Â  Â  Â  Â  Â  if (lastMove && r === (isWhitePiece ? 3 : 4)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const [, fromAlg, toAlg] = top_parseMove(lastMove);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const toCol = toAlg.charCodeAt(0) - 97;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if opponent just moved a pawn two squares next to the current pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const enemyPawn = isWhitePiece ? 'â™Ÿ' : 'â™™';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (b[r][nc] === enemyPawn) { // Check if an enemy pawn is *beside* the capturing pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Note: A real implementation would also check if the *last move* was a two-square advance by that pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc, enPassant: true, captureCol: nc });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }

Â  Â  function top_getValidMoves(r, c) {
Â  Â  Â  Â  const piece = board[r][c];
Â  Â  Â  Â  const pieceFEN = top_pieceToFEN(piece).toUpperCase(); // Use FEN for switch

Â  Â  Â  Â  let moves = [];
Â  Â  Â  Â  switch (pieceFEN) {
Â  Â  Â  Â  Â  Â  case 'R': moves = top_getRookMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'N': moves = top_getKnightMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'B': moves = top_getBishopMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'Q': moves = top_getQueenMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'K': moves = top_getKingMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'S': moves = top_getKingMoves(board, r, c); break; // Superking follows King's simple move rules for 1-square moves
Â  Â  Â  Â  Â  Â  case 'P': moves = top_getPawnMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  default: return [];
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Return only the basic coordinates
Â  Â  Â  Â  return moves.map(m => ({ r: m.r, c: m.c }));
Â  Â  }

Â  Â  /* --- Drawing and Board State (unchanged) --- */

Â  Â  function top_drawBoard() {
Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);

Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  ctx.fillStyle = (r + c) % 2 === 0 ? "#555" : "#777";
Â  Â  Â  Â  Â  ctx.fillRect(c * squareSize, r * squareSize, squareSize, squareSize);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // Selected square highlight
Â  Â  Â  if (selected) {
Â  Â  Â  Â  ctx.fillStyle = "rgba(255,255,0,0.4)";
Â  Â  Â  Â  ctx.fillRect(selected.c * squareSize, selected.r * squareSize, squareSize, squareSize);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Superking path highlight
Â  Â  Â  superkingPath.forEach((p, i) => {
Â  Â  Â  Â  Â  ctx.fillStyle = i === superkingPath.length - 1 ? "rgba(0, 255, 0, 0.7)" : "rgba(0, 255, 0, 0.3)";
Â  Â  Â  Â  Â  ctx.fillRect(p.c * squareSize, p.r * squareSize, squareSize, squareSize);
Â  Â  Â  });

Â  Â  Â  // Draw pieces
Â  Â  Â  ctx.font = "46px Arial";Â 
Â  Â  Â  ctx.textAlign = "center";
Â  Â  Â  ctx.textBaseline = "middle";

Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  const piece = board[r][c];
Â  Â  Â  Â  Â  if (piece) {
Â  Â  Â  Â  Â  Â  // top_isWhite is correct for all pieces including 'â™š'
Â  Â  Â  Â  Â  Â  ctx.fillStyle = top_isWhite(piece) ? "#fff" : "#000";Â 
ctx.fillStyle = top_isWhite(piece) ? "#fff" : "#000";

if (piece === "ðŸ‘‘") {
    let img = new Image();
    img.src = "data:image/webp;base64,UklGRiYFAABXRUJQVlA4IBoFAACQFgCdASpAAEAAPpE4mEiloyIhLBqsALASCWQAvj/3DDF3AVvi4JG3a52zTXqAd2ifE56gkCdwWoj8g+9P7X+ucRd/f9z7OQwLvNrKfdHsAfzH+0/9H1Ks7j1l7B3SgYfzKcJfLLimgD6qzLvEc2r1XgmMgX9lSTPKM+4NahCNjnTapBlSDAfNg2sW+thPJs9fbHoFOnw+k6Xbwfs0An8EemtxsP9TlJQU/FlmeRNefRP+oPE4WT/Ep9o4R2AA/vuzCQGz3MIJylDZjZf29QkIkBn3/ouhimCStse8h/ahKJ3uhAoFY8yKXmNW0NKAdD4R78bSkKyn8EHYY+KP405z4GSSQr1vI4fYfWVGFHntkTJdgUiYyN/XSZvcvMYuEe2z6/yC0TlhAt75f/Whya7z9lBfnHaIOsrw+YNVzITjpBoYerhE+E58PWeKwzrTX84hTm1+3S+BTmIbceQjAgEh08ps7jOaPOI/DQXLc642Yge+utYx5MKzT4+iReNcRepbLz68sxZKN1x/Hxft7aJTDAjuEDsJU9+ndfhq3nFOUUAdDyHirJePHo7u/wr5YMujlV/ceBXGQ/bnfzF6bc73TAqi/fHE53QbYhvsxfQpwZ/ic4JA8g1Dsq7n34ZhMVNvu6/Zv5Sr1VketJ51TEgnVaANzDnFhMmDEAX7s82gpRJE1mg+8gM4r/cjxi2tWsP8w2Y3oRg3mIU2aV67HxEKWgSroMCsFvnHfXPfIIKFjrILlnOQ+E0QgvEDYDEM6Ca6Bs8DQrAW7sn7tIqHy2ScgZ+nm4vjRR5K8t3eV4T3Rx13lPqqFcJDvV7Hlz2/Mk+kZaFxdYp32Kc+c+2RB7ngjfttMXJ5aj7Mqx/3IDgwWgRW34nzReEFbr/x7sqhmtx0jh8uGzsMyxPXzURsPZbFtKkEGzETsGlOp7hSMi9XMifx7sWUtXc+Fxd2HNEoQYBGw0p8aJYI3Gqsswn+bILicd5OjpGfVXI5qpbBS5rtkKxtbsRfv31166hsvrJCuETHHW84k+FMDsm+KagtWS/kiQx2xRIr64/akHMmQnf1W02mzUueoK7ooAp0GBdMssCTw180Y1cMqrIRWIimYbMl/40F+VH0a5Nex6w1kJt+jUNL/kffUxCHhuRDLmwppti9Gkxi27Exk2vpe5bOJsqvRB0KdOf+3qd4OBcDzaPC9/hws3iMRvJfyEUOxlvrcDsCvY5T9OAZpEciI3AO+kxxWD7Tb7HBi4OggU3+YlkqPTgKBvlYNeHmvnGMvTXT6hOLCs2mwE6xaGUBp1+n9QdtKBY7x052sKKKtHseqCgIRn7qWKI9u93thPjqYWmtjcponi19Vwt5Jcs5LVXoWLNnRaycVv8CLmMOg/7/sqT8UjquMXYRSDl2+Ff/V86LiBb5rEdM1qkKnNxZSlIRa0J6sKV9YHeRGVWK1O9IrQMLgMRhrqqAfdSoEbvzifVWPmlVOtI3xn0AsP3mMufU/5KWDiPwZGOiof9ZU6KvmUS88K3ZfJwJCILq5LwybmBdMQ/tYIlrJw49t0ARIJ1IFid2c0sXrOXo4CkSjTmXgOV1O8gErnAtfldvDV5lsNnjZhDm4/IZy0M1q9GTXVUFGrI3iAh0f6GUY6HNZTlB4YrCc5E6x99RzCBF0tdLwbrmhNBtdHtG3pUoL0Gkk3tp+JVY6XIiRvNrwdHdU6pVIXbPfYRaTvpXr25EcIxJRv1Xqxp9wc1OV4El9AAA";
    ctx.drawImage(img, c * squareSize, r * squareSize, squareSize, squareSize);
} else if (piece === "â™š") {
    let img = new Image();
    img.src = "data:image/webp;base64,UklGRlIFAABXRUJQVlA4IEYFAABQFwCdASpAAEAAPpE2lkgloqIhLhtriLASCWQAv2v3DRF8gkvw4G+3yu4CBItBvxfA9iL9jf53y77wb/J7N2V9j9+g/lfQX6waxh457AH8t/s//S/svsJZzXqb2EOj76I/67M8RJmOASMkPvr3PSkQijdXpu/BbrsbsDcEFHg0zWoQmgvZzitswYEk9RjRXt+oyp/W+AEvIVVok4FHa6P1PrQDjGz30B2xg9K20E0M859hQkLEFTfaojzv76BaQvrifwAA/v9jgbdMqsLoFSPRmrekX90tSn3FtWRfxdhBctt7Gon5eT0koDT3jUnmLkBOdyaBG7fmjoIwHpWWLyjknwAgvnrCEymw+0WbQHBvV0f0CU+EiWc10f38MU6PIiKXO2TyoLYBKpB1QGuSfuHq6gP+icw3azYPf67QW3IKU+DeM+rI7eOm1W+tz3q5QlsIdzpTTHH9BGNW+7O1V6/9VyeqU+WvPOcTzATZ11b0phB824f6rCHVjme08ZQcnzR+CLu3wmwvwErMolQBCDwJoL/Vngx8+HR8Q64JmtDs3MAccZfjD6r3EjizW0K1sszj8J9K2dhhVLQZIJzWOevUuU0qvdxhzq8HrQLRQrMQQpHa7RtRMyawJfmioVEzYHDcZxS+NPK94NPf7MUuKWcrGOgwI7nfmt7sVOAkxDyXy14MqUOSd+qS+ibNzyMIB8TAzwo6r/NkseheQLNAJJ2ZNlxCORcnr6MlHwdg6U5VR7kpH4HBk5Epup2DieIdvoJYbD7AhyaeeOG0scPHODtm84wAC9ixwaEzkOd0ZZX3nl5hxOXpuTY3MauikMkYVhNK4SxQQG/O+ymGXATv6Q17tZn5qqevcWCJYySeUpYZ8VETxnPP/UfdiTJPeF98dzsy7piq0Y/NsMqpg+jz1wWtrMolQExLlLuWREAY0ENvtG+lCQ7BXgVujRzcHcnQAaUriebzBZEGdGLN+5kD37JHTVgdCiV+9YBi2W+CLKwbA999dT0dcgePaGbcD1cNKZZtqt4IQb4MXfINE1sGd3hwCm888tIpM6hYf4v90CG+9fo64+CDAfJ/atZOrHrkCcxOozWY8dDYBh+3hzurXJwIdRMXwb7TikJlucg0EOv7/tuotW7r9oMRoRJ4u3+zRMUg0WsobooKxfl5nfatI/5G3pkAVH9GzzPMa55qIjCu27Ecb9f9/WjMlGJ1d5FbNOHjX840FqvNQgmXlVjS5V+miyamVv5hnBPym44EjxhWQI++b0IZOCM0lFVqx0nKhP1oKKjS7Whq2n7Cxxh8ot11U8tv7fQcbDA80JwhKt7XM4r4NK6Lz8xPOMNfgm9b3cvK+tgF1sULW44CgxEBOrPR25aHxixSv37gYpjf2ThERXQRMZniKYIsSVNL+z4QEdiGl5bGSylpM+etkB/LSS92G6t/SWUlTiQSrUZrWDMuQcKhfj2uHeC7X7T8voQVHkqSFeN3gD4KmjEYge0Akhu8edwX+R2/0GYfJ0DNG2rlq4ILWkefbZMiuz3GG0Veb9akvoVi3iYoRNB2VAlbzzUYrbE4HsO2OirwbRNTi2ezzZSb6etoKc1NE6xY8YE172CHQtGkAy81Lx1jryS5Hi3v3g469ngbuJ1rihl4x7KLAnP+NiNh4MXFiYlI+cPixFlkIaN4goDLepmEzRtUPIomV4hytr+ETCWG3MaGRjTWsMt9wPoegfP8dOXHcerYVc0Gddntkrbm/NVAYQmfpMDK966Y4Dt2mzdF3Xvz3Py0ilT1yrElvhQm951B+HJDSk7nF6w7gAA=";
    ctx.drawImage(img, c * squareSize, r * squareSize, squareSize, squareSize);
} else {
    ctx.fillText(piece, c * squareSize + squareSize / 2, r * squareSize + squareSize / 2 + 2);
}
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  /* --- EVENT HANDLERS (unchanged) --- */

Â  Â  canvas.addEventListener("click", (e) => {
Â  Â  Â  const rect = canvas.getBoundingClientRect();
Â  Â  Â  const x = e.clientX - rect.left;
Â  Â  Â  const y = e.clientY - rect.top;
Â  Â  Â  const c = Math.floor(x / squareSize);
Â  Â  Â  const r = Math.floor(y / squareSize);
Â  Â  Â  const clicked = board[r][c];

Â  Â  Â  if (selected) {
Â  Â  Â  Â  const piece = board[selected.r][selected.c];

Â  Â  Â  Â  // 1. Superking Path Logic (White is 'ðŸ‘‘', Black is 'â™š')
Â  Â  Â  Â  if (piece === 'ðŸ‘‘' || piece === 'â™š') {
Â  Â  Â  Â  Â  const last = superkingPath[superkingPath.length - 1] || selected;
Â  Â  Â  Â  Â  const isAdjacent = Math.abs(last.r - r) <= 1 && Math.abs(last.c - c) <= 1;
Â  Â  Â  Â  Â  const isDuplicate = superkingPath.some((p, i) => i > 0 && p.r === r && p.c === c);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (isAdjacent && superkingPath.length < 4) {
Â  Â  Â  Â  Â  Â  superkingPath.push({ r, c });
Â  Â  Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  } else if (!isAdjacent) {
Â  Â  Â  Â  Â  Â  alert("Each Superking move must be to an adjacent square!");
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 2. Standard Move Logic
Â  Â  Â  Â  const allPawnMoves = top_getPawnMoves(board, selected.r, selected.c);
Â  Â  Â  Â  const validMoves = top_getValidMoves(selected.r, selected.c);
Â  Â  Â  Â  const targetMove = validMoves.find(m => m.r === r && m.c === c);

Â  Â  Â  Â  if (targetMove) {
Â  Â  Â  Â  Â  history.push(top_copyBoard(board));
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  let notation = piece + top_coordsToAlgebraic(selected.r, selected.c) + top_coordsToAlgebraic(r, c);
Â  Â  Â  Â  Â  let newPiece = piece;
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Check for promotion (full move list needed for the flag)
Â  Â  Â  Â  Â  const promotionFlag = allPawnMoves.find(m => m.r === r && m.c === c && m.promote);
Â  Â  Â  Â  Â  if (promotionFlag) {
Â  Â  Â  Â  Â  Â  Â  newPiece = top_handlePawnPromotion(r, c, piece);
Â  Â  Â  Â  Â  Â  Â  notation += top_pieceToFEN(newPiece).toUpperCase(); // Add promotion notation (e.g., Q)
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // Check for en passant (full move list needed for the flag)
Â  Â  Â  Â  Â  const enPassantFlag = allPawnMoves.find(m => m.r === r && m.c === c && m.enPassant);
Â  Â  Â  Â  Â  if (enPassantFlag) {
Â  Â  Â  Â  Â  Â  Â  // Clear the captured pawn
Â  Â  Â  Â  Â  Â  Â  const capturedPawnRow = selected.r;
Â  Â  Â  Â  Â  Â  Â  board[capturedPawnRow][enPassantFlag.captureCol] = '';
Â  Â  Â  Â  Â  Â  Â  notation += " e.p.";
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // If a piece was captured, notation should reflect it
Â  Â  Â  Â  Â  if (clicked !== '') {
Â  Â  Â  Â  Â  Â  Â  notation = notation.slice(0, 3) + 'x' + notation.slice(3);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  board[r][c] = newPiece;Â 
Â  Â  Â  Â  Â  board[selected.r][selected.c] = '';
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  lastMove = notation;
Â  Â  Â  Â  Â  moveLog.push(notation);
Â  Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  Â  Â  top_updateLog();
Â  Â  Â  Â  Â  top_showVerse();
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // Clear selection or select a new piece of the same color
Â  Â  Â  Â  Â  if (clicked && top_isWhite(clicked) === top_isWhite(piece)) {
Â  Â  Â  Â  Â  Â  Â  selected = { r, c };
Â  Â  Â  Â  Â  Â  Â  superkingPath = (clicked === 'ðŸ‘‘' || clicked === 'â™š') ? [{ r, c }] : [];
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } else if (clicked) {
Â  Â  Â  Â  // No piece selected, so select the clicked piece
Â  Â  Â  Â  selected = { r, c };
Â  Â  Â  Â  if (clicked === 'ðŸ‘‘' || clicked === 'â™š') {
Â  Â  Â  Â  Â  superkingPath = [{ r, c }];
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  // Clicked on an empty square with no piece selected
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  }

Â  Â  Â  top_drawBoard();
Â  Â  });

    // *** SUPERKING MOVE LOGIC (UPDATED: Removed capture notation) ***
Â  Â  function top_finishSuperkingMove() {
Â  Â  Â  const piece = board[selected.r][selected.c];
Â  Â  Â  if (!selected || (piece !== 'ðŸ‘‘' && piece !== 'â™š') || superkingPath.length < 2) {
Â  Â  Â  Â  alert("Superking move requires at least two squares and the Superking to be selected!");
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  history.push(top_copyBoard(board));

Â  Â  Â  const path = superkingPath.map(sq => top_coordsToAlgebraic(sq.r, sq.c));
Â  Â  Â  const first = superkingPath[0];
Â  Â  Â  const last = superkingPath[superkingPath.length - 1];

Â  Â  Â  // Determine notation character ('S' for white, 's' for black)
Â  Â  Â  const superkingNotation = top_isWhite(piece) ? 'S' : 's';

Â  Â  Â  // 1. Clear pieces from intermediate squares (index 1 up to, but not including, the last square)
Â  Â  Â  for (let i = 1; i < superkingPath.length - 1; i++) {
Â  Â  Â  Â  Â  const intermediate = superkingPath[i];
Â  Â  Â  Â  Â  board[intermediate.r][intermediate.c] = '';
Â  Â  Â  }

Â  Â  Â  // 2. Move piece to the last square (this handles the final capture)
Â  Â  Â  board[last.r][last.c] = piece; // Use the original piece symbol ('ðŸ‘‘' or 'â™š')
Â  Â  Â Â 
Â  Â  Â  // 3. Clear the starting square only if the piece actually moved
Â  Â  Â  if (first.r !== last.r || first.c !== last.c) {
Â  Â  Â  Â  board[first.r][first.c] = '';
Â  Â  Â  }

Â  Â  Â  // Construct the move notation (NO CAPTURE NOTATION APPENDED)
Â  Â  Â  let notation = superkingNotation + path.join("");
Â  Â  Â Â 
Â  Â  Â  lastMove = notation;
Â  Â  Â  moveLog.push(notation);
Â  Â  Â  selected = null;
Â  Â  Â  superkingPath = [];

Â  Â  Â  top_drawBoard();
Â  Â  Â  top_updateLog();
Â  Â  Â  top_showVerse();
Â  Â  }
Â  Â Â 
Â  Â  function top_takeBackMove() {
Â  Â  Â  if (history.length > 1) {
Â  Â  Â  Â  history.pop();
Â  Â  Â  Â  board = top_copyBoard(history[history.length - 1]);
Â  Â  Â  Â  moveLog.pop();
Â  Â  Â  Â  lastMove = moveLog.length > 0 ? moveLog[moveLog.length - 1] : null;
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  Â  top_updateLog();
Â  Â  Â  }
Â  Â  }

Â  Â  /* --- FEN & IO (unchanged from last step) --- */

Â  Â  function top_applyFEN(fen) {
Â  Â  Â  const parts = fen.trim().split(' ');
Â  Â  Â  const ranks = parts[0].split('/');
Â  Â  Â  board = Array.from({length: boardSize}, () => Array(boardSize).fill('')); // Clear board

Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  let row = ranks[r] || '';
Â  Â  Â  Â  let c = 0;
Â  Â  Â  Â  for (let ch of row) {
Â  Â  Â  Â  Â  if (c >= boardSize) break;
Â  Â  Â  Â  Â  if (!isNaN(ch)) {
Â  Â  Â  Â  Â  Â  c += parseInt(ch);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  board[r][c] = top_FENtoPiece(ch);
Â  Â  Â  Â  Â  Â  c++;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }



Â  Â  function top_loadPosition() {
Â  Â  Â  // NOTE: This function now reads from 'topFenInput'
Â  Â  Â  const fen = document.getElementById("topFenInput").value; 
Â  Â  Â  if (fen) {
Â  Â  Â  Â  top_applyFEN(fen);
Â  Â  Â  Â  history = [top_copyBoard(board)];
Â  Â  Â  Â  moveLog = [];
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  lastMove = null;
Â  Â  Â  Â  top_updateLog();
Â  Â  Â  Â  // Since the loaded FEN might have turn data, we read it or default to 'w'
Â  Â  Â  Â  const parts = fen.trim().split(' ');
Â  Â  Â  Â  const loadColor = (parts.length > 1 && parts[1].toLowerCase() === 'b') ? 'b' : 'w';
Â  Â  Â  Â  // Show position also triggers the full FEN transfer to the bottom AI's input
Â  Â  Â  Â  top_showPosition(loadColor);Â 
Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  function top_updateLog() {
Â  Â  Â  document.getElementById("log").textContent = "Move Log:\n" + moveLog.join("\n");
Â  Â  }

Â  Â  function top_copyFENButtonAction() {
Â  Â  Â  const fullFEN = top_showPosition('w'); // Generates full FEN (and updates the bottom fenInput)
Â  Â  Â  top_copyToClipboard(fullFEN).then(() => alert('FEN copied!')).catch(err => alert('Failed to copy FEN: ' + err));
Â  Â  }

    // *** NEW FUNCTION to copy the contents of the Move Log ***
    function top_copyLog() {
        // Get the text content, removing the "Move Log:\n" header
        const logContent = document.getElementById("log").textContent.replace("Move Log:\n", "");
        top_copyToClipboard(logContent).then(() => alert('Move Log copied!')).catch(err => alert('Failed to copy Move Log: ' + err));
    }

Â  Â  function top_copyToClipboard(text) {
Â  Â  Â  if (navigator.clipboard && navigator.clipboard.writeText) {
Â  Â  Â  Â  return navigator.clipboard.writeText(text);
Â  Â  Â  }
Â  Â  Â  return new Promise((resolve, reject) => {
Â  Â  Â  Â  const textarea = document.createElement("textarea");
Â  Â  Â  Â  textarea.value = text;
Â  Â  Â  Â  textarea.style.position = 'fixed';
Â  Â  Â  Â  document.body.appendChild(textarea);
Â  Â  Â  Â  textarea.select();
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  Â  document.body.removeChild(textarea);
Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  document.body.removeChild(textarea);
Â  Â  Â  Â  Â  reject(err);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }
Â  Â Â 
Â  Â  /* --- Verse Logic (unchanged) --- */

Â  Â  function top_showVerse() {
Â  Â  Â  const verseDisplay = document.getElementById("verseDisplay");
Â  Â  Â  if (verseDisplay) {
Â  Â  Â  Â  verseDisplay.textContent = verses[verseIndex];
Â  Â  Â  Â  verseIndex = (verseIndex + 1) % verses.length;
Â  Â  Â  }
Â  Â  }

Â  Â  /* --- INITIALIZATION (unchanged) --- */
Â  Â  top_initBoard();

Â  Â  function top_initBoard() {
Â  Â  Â  board = Array.from({length: boardSize}, () => Array(boardSize).fill(''));
Â  Â  Â  // Starting FEN for board setup: rnbqsbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQSBNR
Â  Â  Â  const setup = "rnbqsbnr/ppppp1pp/5p2/8/8/5P2/PPPPP1PP/RNBQSBNR";Â 
Â  Â  Â  top_applyFEN(setup);
Â  Â  Â  history = [top_copyBoard(board)];
Â  Â  Â  moveLog = [];
Â  Â  Â  selected = null;
Â  Â  Â  superkingPath = [];
Â  Â  Â  lastMove = null;
Â  Â  Â  top_drawBoard();
Â  Â  Â  top_updateLog();
Â  Â  Â  top_showPosition('w'); // Initial position displays 'w' to move (and transfers full FEN to bottom input)
Â  Â  }
Â  </script>




///capture.js
<script> 
///capture.js
/* capture.js â€“ capture the best move + show FEN after applying it */
function captureMove() {
  // 1. Grab UI values
  const bestMoveText = document.getElementById("bestMoveDisplay").textContent.trim();
  const currentFEN    = document.getElementById("fenInput").value.trim();

  // 2. Parse move & score
  const moveMatch = bestMoveText.match(/Best Move:\s*(.*?)\s*\|/);
  const scoreMatch = bestMoveText.match(/\|\s*Score:\s*(\d+)/);

  const cleanedMove = moveMatch ? moveMatch[1].replace(/Ã¢â€ â€™|â†’|->/g, "").trim() : "Unavailable";
  const score       = scoreMatch ? scoreMatch[1] : "Unknown";

  // 3. Show captured move & original FEN
  document.getElementById("captureMoveOutput").value = `${cleanedMove} | Score: ${score}`;
  document.getElementById("captureFENOutput").value  = currentFEN;

  // 4. Apply the move and show the new FEN
  const newFEN = applyMoveToFEN(currentFEN, cleanedMove);
  document.getElementById("appliedFENOutput").value = newFEN;
}

/* ------------------------------------------------------------------
   Helper: apply a path move (exactly like your Python script)
   ------------------------------------------------------------------ */
function applyMoveToFEN(fen, pathStr) {
  if (!pathStr || pathStr === "Unavailable") return fen;

  // ---- parse FEN parts ------------------------------------------------
  const parts = fen.split(/\s+/);
  const boardRows = parts[0].split('/');
  const turn = parts[1] || 'w';
  const castling = parts[2] || '-';
  const enPassant = parts[3] || '-';
  const halfmove = parts[4] || '0';
  const fullmove = parts[5] || '1';

  // ---- build 8x8 board ------------------------------------------------
  const board = [];
  for (let r of boardRows) {
    const row = [];
    for (let ch of r) {
      if (/\d/.test(ch)) {
        row.push(...Array(+ch).fill(null));
      } else {
        row.push(ch);
      }
    }
    board.push(row);
  }

  // ---- parse path: "(file,rank) (file,rank) ..." ----------------------
  const coordRE = /\((\d+),(\d+)\)/g;
  const matches = [...pathStr.matchAll(coordRE)];
  if (matches.length < 2) return fen;               // need at least start+end

  const coords = matches.map(m => {
    const file = +m[1];      // 1-8 (a-h)
    const rank = +m[2];      // 1-8 (bottom-top)
    return { r: 8 - rank, c: file - 1 };   // 0-based row/col
  });

  const start = coords[0];
  const end   = coords[coords.length - 1];

  const piece = board[start.r][start.c];
  if (!piece) return fen;                    // nothing to move

  // ---- perform the move -----------------------------------------------
  board[start.r][start.c] = null;
  const captured = board[end.r][end.c];
  board[end.r][end.c] = piece;

  // ---- update FEN metadata --------------------------------------------
  const newTurn = turn === 'w' ? 'b' : 'w';

  const isPawn = piece.toLowerCase() === 'p';
  const isCapture = captured !== null;
  const newHalf = (isPawn || isCapture) ? '0' : String(+halfmove + 1);

  const newFull = turn === 'b' ? String(+fullmove + 1) : fullmove;

  // castling â€“ strip rights for the side that moved a king
  let newCast = castling;
  if (piece.toLowerCase() === 'k') {
    const side = piece === 'k' ? 'kq' : 'KQ';
    newCast = newCast.replace(new RegExp(`[${side}]`, 'g'), '');
  }

  const newEP = '-';   // simplified â€“ real engine would compute it

  // ---- rebuild FEN string ---------------------------------------------
  const fenRows = board.map(row => {
    let str = '';
    let empty = 0;
    for (let cell of row) {
      if (cell === null) { empty++; }
      else {
        if (empty) { str += empty; empty = 0; }
        str += cell;
      }
    }
    if (empty) str += empty;
    return str;
  });

  return `${fenRows.join('/')} ${newTurn} ${newCast} ${newEP} ${newHalf} ${newFull}`;
}

 </script>


///bestmove.js
<script> 
function bestMove() {
  const output = document.getElementById("output").value;
  const lines = output.split("\n");
  const moveLines = lines.filter(line => line.includes("â†’") && line.includes("Score:"));

  if (moveLines.length === 0) {
    document.getElementById("bestMoveDisplay").textContent = "No valid scored paths found.";
    return;
  }

  // Find the highest score and return the full line
  let topScore = -Infinity;
  let bestLine = "";

  moveLines.forEach(line => {
    const scoreMatch = line.match(/Score:\s*(\d+)/);
    if (scoreMatch) {
      const score = parseInt(scoreMatch[1]);
      if (score > topScore) {
        topScore = score;
        bestLine = line;
      }
    }
  });

  document.getElementById("bestMoveDisplay").textContent = `Best Move: ${bestLine}`;
}

 </script>


///r.js
<script> 
function rookPaths(x, y) {
  const directions = [[1,0], [-1,0], [0,1], [0,-1]];
  return linearPaths(x, y, directions);
}
</script>


///q.js
<script> 
function queenPaths(x, y) {
  const directions = [
    [1,0], [-1,0], [0,1], [0,-1],
    [1,1], [1,-1], [-1,1], [-1,-1]
  ];
  return linearPaths(x, y, directions);
}
</script>

///b.js
<script> 
function bishopPaths(x, y) {
  const directions = [[1,1], [1,-1], [-1,1], [-1,-1]];
  return linearPaths(x, y, directions);
}
</script>


///n.js
<script> 
function knightPaths(x, y) {
  const moves = [
    [1, 2], [2, 1], [-1, 2], [-2, 1],
    [1, -2], [2, -1], [-1, -2], [-2, -1]
  ];

  const onBoard = ([a, b]) => a >= 1 && a <= 8 && b >= 1 && b <= 8;
  const isObstacle = ([a, b]) => obstacles.includes(`${a},${b}`);
  const getScore = ([a, b]) => targets.get(`${a},${b}`) || 0;

  const paths = [];

  for (let [dx, dy] of moves) {
    const nx = x + dx;
    const ny = y + dy;
    if (onBoard([nx, ny]) && !isObstacle([nx, ny])) {
      const path = [[x, y], [nx, ny]];
      const score = getScore([nx, ny]);
      paths.push({ path, score });
    }
  }

  paths.sort((a, b) => b.score - a.score || a.path.length - b.path.length);
  return paths;
}
 </script>



///p.js
<script>
function pawnPaths(x, y, isWhite = true) {
  const direction = isWhite ? 1 : -1;
  const startRank = isWhite ? 2 : 7;
  const promotionRank = isWhite ? 8 : 1;

  const fenInput = document.getElementById("fenInput");
  const enPassant = fenInput ? fenInput.value.split(" ")[3] : '-';

  const onBoard = ([a, b]) => a >= 1 && a <= 8 && b >= 1 && b <= 8;
  const isObstacle = ([a, b]) => obstacles.includes(`${a},${b}`);
  const getScore = ([a, b]) => targets.get(`${a},${b}`) || 0;

  const pieceValues = { Q: 9, R: 3.5, N: 3, B: 3.01, P: 1, S: 10000 };
  const paths = [];

  // Forward move (must be empty)
  const oneStep = [x, y + direction];
  if (onBoard(oneStep) && !isObstacle(oneStep) && !targets.has(`${oneStep[0]},${oneStep[1]}`)) {
    if (oneStep[1] === promotionRank) {
      for (let promo of ['Q', 'R', 'N', 'B', 'P']) {
        const score = pieceValues[promo];
        paths.push({ path: [[x, y], oneStep], promotion: promo, score });
      }
    } else {
      paths.push({ path: [[x, y], oneStep], score: 0 });
    }

    // Two-step move from starting rank
    const twoStep = [x, y + 2 * direction];
    if (y === startRank && onBoard(twoStep) && !isObstacle(twoStep) && !targets.has(`${twoStep[0]},${twoStep[1]}`)) {
      paths.push({ path: [[x, y], twoStep], score: 0 });
    }
  }

  // Captures
  for (let dx of [-1, 1]) {
    const diag = [x + dx, y + direction];
    if (onBoard(diag)) {
      const targetScore = getScore(diag);
      if (targetScore > 0) {
        if (diag[1] === promotionRank) {
          for (let promo of ['Q', 'R', 'N', 'B', 'P']) {
            const score = pieceValues[promo] + targetScore;
            paths.push({ path: [[x, y], diag], promotion: promo, score });
          }
        } else {
          paths.push({ path: [[x, y], diag], score: targetScore });
        }
      }
    }
  }

  // En passant
  if (/^[a-h][36]$/.test(enPassant)) {
    const epFile = enPassant.charCodeAt(0) - 96;
    const epRank = parseInt(enPassant[1]);
    if (Math.abs(epFile - x) === 1 && epRank === y + direction) {
      paths.push({ path:[[x, y], [epFile, epRank]], type: 'enPassant', score: 1 });
    }
  }

  paths.sort((a, b) => b.score - a.score || a.path.length - b.path.length);
  return paths;
}


 </script>



///skt.js
<script> 
/* -------------------------------------------------------------
   skt.js  â€“  SKT path generator with the exact deduplication
   you asked for (clockwise loops kept, anticlockwise dropped,
   abab â†’ ab, etc.)
   ------------------------------------------------------------- */
function SktScoreObstacles(x, y) {
  const dirs = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];

  const onBoard = ([a, b]) => a >= 1 && a <= 8 && b >= 1 && b <= 8;
  const isFriendly = ([a, b]) => obstacles.includes(`${a},${b}`);
  const getScore   = ([a, b]) => targets.get(`${a},${b}`) || 0;

  const startKey = `${x},${y}`;
  const allPaths = [];

  // ---------- 1. Generate every legal 1-3-move path ----------
  for (const d1 of dirs) {
    const p1 = [x + d1[0], y + d1[1]];
    if (!onBoard(p1) || isFriendly(p1)) continue;

    allPaths.push({ path: [[x, y], p1], score: calcScore([[x, y], p1]) });

    for (const d2 of dirs) {
      const p2 = [p1[0] + d2[0], p1[1] + d2[1]];
      if (!onBoard(p2) || isFriendly(p2)) continue;

      allPaths.push({ path: [[x, y], p1, p2], score: calcScore([[x, y], p1, p2]) });

      for (const d3 of dirs) {
        const p3 = [p2[0] + d3[0], p2[1] + d3[1]];
        if (!onBoard(p3) || isFriendly(p3)) continue;

        allPaths.push({ path: [[x, y], p1, p2, p3], score: calcScore([[x, y], p1, p2, p3]) });
      }
    }
  }

  // ---------- 2. Helper: score (unique captures) ----------
  function calcScore(path) {
    const seen = new Set();
    let s = 0;
    for (const pos of path) {
      const k = `${pos[0]},${pos[1]}`;
      if (!seen.has(k)) { seen.add(k); s += getScore(pos); }
    }
    return s;
  }

  // ---------- 3. Helper: clockwise test ----------
  // For a 4-step loop aâ†’bâ†’câ†’a we look at the three vectors.
  // If the cross-product chain is positive â†’ clockwise.
  function isClockwiseLoop(path) {
    if (path.length !== 4) return false;
    const [a, b, c, d] = path;
    if (`${d[0]},${d[1]}` !== startKey) return false; // must end at start

    const v1 = [b[0] - a[0], b[1] - a[1]];
    const v2 = [c[0] - b[0], c[1] - b[1]];
    const v3 = [d[0] - c[0], d[1] - c[1]];

    // cross products v1Ã—v2 and v2Ã—v3
    const cross1 = v1[0] * v2[1] - v1[1] * v2[0];
    const cross2 = v2[0] * v3[1] - v2[1] * v3[0];
    return cross1 > 0 && cross2 > 0;
  }

  // ---------- 4. Deduplication ----------
  const keep = new Map(); // key â†’ best path object

  for (const item of allPaths) {
    const path = item.path;
    const endKey = `${path[path.length - 1][0]},${path[path.length - 1][1]}`;

    // 4-a)  abab  â†’ keep only ab
    if (path.length === 4 && endKey === `${path[1][0]},${path[1][1]}`) {
      // this is aâ†’bâ†’aâ†’b  â†’ ignore, the 2-step aâ†’b will be kept later
      continue;
    }

    // 4-b)  Clockwise 4-step loop (abca) â€“ keep it
    if (path.length === 4 && endKey === startKey && isClockwiseLoop(path)) {
      const sig = `loop_cw_${path.map(p => `${p[0]},${p[1]}`).join('|')}`;
      keep.set(sig, item);
      continue;
    }

    // 4-c)  Anything that returns to start **without** being a clockwise loop â†’ drop
    if (endKey === startKey) continue;

    // 4-d)  Normal paths â€“ group by *captured squares* (ignore order)
    const captured = new Set();
    for (let i = 1; i < path.length; i++) captured.add(`${path[i][0]},${path[i][1]}`);
    const captureKey = Array.from(captured).sort().join('|');

    const existing = keyExists(captureKey);
    if (!existing) {
      keep.set(captureKey, item);
      continue;
    }

    // same captures â†’ keep the **shortest** (or highest score if lengths equal)
    if (item.score > existing.score ||
        (item.score === existing.score && path.length < existing.path.length)) {
      keep.set(captureKey, item);
    }
  }

  // Helper for the map lookup
  function keyExists(k) {
    return keep.has(k) ? keep.get(k) : null;
  }

  // ---------- 5. Final sort ----------
  const result = Array.from(keep.values());
  result.sort((a, b) => b.score - a.score || a.path.length - b.path.length);
  return result;
}

 </script>

///applyMove.js
<script> 
///applyMove.js
function applyBestMove() {
  const moveText = document.getElementById("bestMoveDisplay").innerText.trim();
  if (!moveText || !moveText.includes("(")) {
    alert("No valid best move found.");
    return;
  }

  // Parse move path like (5,8) â†’ (6,7) â†’ (7,7)
  const regex = /\((\d),(\d)\)/g;
  const path = [];
  let match;
  while ((match = regex.exec(moveText)) !== null) {
    path.push([parseInt(match[1], 10), parseInt(match[2], 10)]);
  }

  if (path.length < 2) {
    alert("Move path too short to apply.");
    return;
  }

  const board = document.getElementById("board");
  const getCell = (x, y) => board.rows[8 - y].cells[x - 1];

  // Get the piece from the first square in the path
  const [fromX, fromY] = path[0];
  const sourceCell = getCell(fromX, fromY);
  const piece = sourceCell.innerText.trim();

  if (!piece) {
    alert("No piece found at source square.");
    return;
  }

  // Clear the source square
  sourceCell.innerText = "";

  // Clear intermediate squares along the path (captures)
  for (let i = 1; i < path.length - 1; i++) {
    const [x, y] = path[i];
    const cell = getCell(x, y);
    if (cell.innerText.trim() !== "") {
      cell.innerText = ""; // remove captured piece
    }
  }

  // Final destination
  const [toX, toY] = path[path.length - 1];
  let finalPiece = piece;

  // --- Pawn Promotion Logic inferred from score ---
  if (piece.toLowerCase() === "p" && (toY === 8 || toY === 1)) {
    const scoreMatch = moveText.match(/Score:\s*([\d.]+)/);
    const score = scoreMatch ? parseFloat(scoreMatch[1]) : null;
    const isWhitePawn = piece === "P";

    if (score !== null) {
      const promoPiece = mapPromoFromScore(score);
      finalPiece = isWhitePawn ? promoPiece.toUpperCase() : promoPiece.toLowerCase();
    } else {
      // Fallback: default to queen
      finalPiece = isWhitePawn ? "Q" : "q";
    }
  }

  // Place the piece at the final destination
  getCell(toX, toY).innerText = finalPiece;

  // Update FEN turn
  const fenInput = document.getElementById("fenInput").value.trim();
  const fenParts = fenInput.split(" ");
  if (fenParts.length < 6) {
    alert("Invalid FEN format.");
    return;
  }

  const currentTurn = fenParts[1];
  const nextTurn = currentTurn === "w" ? "b" : "w";
  fenParts[1] = nextTurn;

  const newFEN = generateFENFromBoard() + " " + fenParts.slice(1).join(" ");
  document.getElementById("finalFENOutput").value = newFEN;
}

// Map a move score to a promotion piece, handling SKT base and normal capture sums
function mapPromoFromScore(score) {
  const SKT_BASE = 10000;

  // Promotion values (note bishop = 3.01)
  const promoMap = [
    { val: 9,   piece: "Q" },
    { val: 3.5, piece: "R" },
    { val: 3.01,piece: "B" },
    { val: 3,   piece: "N" },
    { val: 1,   piece: "P" },
  ];

  // Capture values (normal pieces)
  const captureVals = [9, 3.5, 3, 1];

  // If SKT captured, remove base and match exactly
  if (score >= SKT_BASE) {
    const val = +(score - SKT_BASE).toFixed(2);
    for (const { val: pv, piece } of promoMap) {
      if (pv === val) return piece;
    }
    return "Q"; // fallback
  }

  // Otherwise: score may be promoValue + capturedPieceValue
  for (const { val: pv, piece } of promoMap) {
    const remaining = +(score - pv).toFixed(2);
    if (captureVals.includes(remaining)) return piece;
  }

  // If no exact match, fallback to queen
  return "Q";
}

function generateFENFromBoard() {
  const board = document.getElementById("board");
  let fen = "";

  for (let row = 0; row < 8; row++) {
    let empty = 0;
    for (let col = 0; col < 8; col++) {
      const cell = board.rows[row].cells[col];
      const piece = cell.innerText.trim();
      if (!piece) {
        empty++;
      } else {
        if (empty > 0) {
          fen += empty;
          empty = 0;
        }
        fen += piece;
      }
    }
    if (empty > 0) fen += empty;
    if (row < 7) fen += "/";
  }

  return fen;
}


 </script>



///transfer.js
<script> 
/// transfer.js
function transferFinalFEN() {
  const finalFen = document.getElementById("finalFENOutput").value.trim();
  const fenInput = document.getElementById("fenInput");
  const moveLogs = document.getElementById("moveLogs");
  const bestMove = document.getElementById("bestMoveDisplay").innerText.trim();

  if (!finalFen) {
    alert("No Final FEN available to transfer.");
    return;
  }

  // Copy Final FEN into FEN Input field
  fenInput.value = finalFen;

  // Append move + FEN into game log
  const logEntry = `Transferred Move: ${bestMove || "(unknown move)"}\nFEN: ${finalFen}\n\n`;
  moveLogs.value += logEntry;

  // Optional: scroll to bottom of logs
  moveLogs.scrollTop = moveLogs.scrollHeight;
}


 </script>



///copyMoveLogs.js
<script> 
/// copyMoveLogs.js

/**
 * Selects and copies the content of the moveLogs textarea.
 * Provides visual feedback on the button upon successful copy.
 */
function copyMoveLogs(event) {
  const logs = document.getElementById('moveLogs');
  if (!logs) return;

  // Get the element that triggered the function (likely a button)
  const triggerBtn = event ? event.target : null;

  // ---------- 1. SELECT ALL CONTENTS (FOR VISUAL FEEDBACK / MANUAL COPY) ----------
  // For <textarea> or <input>
  if (logs.tagName === 'TEXTAREA' || logs.tagName === 'INPUT') {
    logs.focus();
    logs.select();
    logs.setSelectionRange(0, 99999); // mobile
  }
  // For <div>, <pre>, etc. â€“ use Range selection
  else {
    const range = document.createRange();
    range.selectNodeContents(logs);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  // ---------- 2. GET TEXT ONLY (what we actually copy) ----------
  const textToCopy = logs.value || logs.textContent || logs.innerText || '';

  // ---------- 3. COPY (modern + fallback) ----------
  if (navigator.clipboard && navigator.clipboard.writeText) {
    // Modern Approach: Copy the text variable directly
    navigator.clipboard.writeText(textToCopy)
      .then(() => showCopiedFeedback(triggerBtn))
      .catch(() => fallbackCopy(textToCopy, triggerBtn));
  } else {
    // Fallback if modern API isn't available
    fallbackCopy(textToCopy, triggerBtn);
  }
}

// --- Fallback: execCommand (Deprecated but useful for older browsers) ---
function fallbackCopy(text, triggerBtn) {
  let temp;
  try {
    // Create temporary textarea to copy clean text
    temp = document.createElement('textarea');
    temp.value = text;
    // Style to hide it off-screen
    temp.style.position = 'fixed';
    temp.style.top = '0';
    temp.style.left = '-9999px';
    document.body.appendChild(temp);
    
    // Select the content of the temporary element
    temp.focus();
    temp.select();
    temp.setSelectionRange(0, 99999); // Mobile compatibility

    const success = document.execCommand('copy');
    
    if (success) {
      showCopiedFeedback(triggerBtn);
    } else {
      alert('Copy failed â€“ please select and copy manually.');
    }
  } catch (err) {
    alert('Copy failed â€“ your browser may block it.');
  } finally {
    // Clean up the temporary element
    if (temp) {
      document.body.removeChild(temp);
    }
  }
}

// ---------- Visual feedback (Pass the button element) ----------
function showCopiedFeedback(btn) {
  if (!btn) return;
  const oldText = btn.innerText;
  const oldBg = btn.style.backgroundColor;
  const oldColor = btn.style.color;

  btn.innerText = 'Copied!';
  btn.style.backgroundColor = '#4CAF50';
  btn.style.color = 'white';
  
  setTimeout(() => {
    btn.innerText = oldText;
    btn.style.backgroundColor = oldBg;
    btn.style.color = oldColor;
  }, 1500);
}

 </script>


///autoPlayCycles.js
<script> 

///autoPlayCycles.js
/**
 * Automates the game cycle: load FEN, find best move, apply best move,
 * update FEN, and log the results for a specified number of cycles.
 * @param {number} cycles - The number of turns/moves to play automatically.
 */
async function autoPlayCycles(cycles = 50) {
  const moveLogs = document.getElementById("moveLogs");
  moveLogs.value = "";

  for (let i = 1; i <= cycles; i++) {
    loadFEN();
    await new Promise(resolve => setTimeout(resolve, 300));
    bestMove();
    await new Promise(resolve => setTimeout(resolve, 300));
    applyBestMove();
    await new Promise(resolve => setTimeout(resolve, 300));

    const move = document.getElementById("bestMoveDisplay").innerText.trim() ||
                 document.getElementById("captureMoveOutput").value.trim();
    const newFen = document.getElementById("finalFENOutput").value.trim();
    document.getElementById("fenInput").value = newFen;

    moveLogs.value += `${i}. Move: ${move}\n    FEN: ${newFen}\n\n`;
    await new Promise(resolve => setTimeout(resolve, 500));
  }
}

 </script>


///bestMoveTwoPlies.js
<script> 
///bestMoveTwoPlies.js
/**
 * Performs a two-ply (two-move lookahead) search based on existing path data 
 * in the 'output' field to determine the best move.
 */
async function bestMoveTwoPlies() {
  loadFEN();
  await new Promise(r => setTimeout(r, 100));

  const output = document.getElementById("output").value;
  const pathLines = output.trim().split('\n')
    .filter(l => l.includes('â†’') && l.includes('Score:'));

  if (pathLines.length === 0) {
    document.getElementById("bestMoveDisplay").innerText = "No moves found.";
    return;
  }

  const originalFen = document.getElementById("fenInput").value.trim();
  let bestNetScore = -Infinity;
  let bestMoves = [];

  for (let line of pathLines) {
    const moveText = line.split(' | ')[0];
    const myScore = parseFloat(line.match(/Score:\s*([\d.]+)/)[1]);

    // Simulate my move
    document.getElementById("bestMoveDisplay").innerText = moveText;
    applyBestMove();
    await new Promise(r => setTimeout(r, 50));

    const afterMyMoveFen = document.getElementById("finalFENOutput").value.split(' ')[0];
    const opponentTurn = currentTurn === 'w' ? 'b' : 'w';
    document.getElementById("fenInput").value = afterMyMoveFen + " " + opponentTurn;

    loadFEN();
    await new Promise(r => setTimeout(r, 100));

    const oppOutput = document.getElementById("output").value;
    const oppLines = oppOutput.trim().split('\n')
      .filter(l => l.includes('â†’') && l.includes('Score:'));
    const oppBestScore = oppLines.length > 0
      ? Math.max(...oppLines.map(l => parseFloat(l.match(/Score:\s*([\d.]+)/)[1]) || 0))
      : 0;

    // Restore board
    document.getElementById("fenInput").value = originalFen;
    loadFEN();

    const SKT_LOSS = 10000;
    const penalty = oppBestScore >= SKT_LOSS - 1 ? -1e9 : 0;
    const netScore = myScore - oppBestScore + penalty;

    if (netScore > bestNetScore) {
      bestNetScore = netScore;
      bestMoves = [moveText];
    } else if (Math.abs(netScore - bestNetScore) < 0.01) {
      bestMoves.push(moveText);
    }
  }

  const chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
  document.getElementById("bestMoveDisplay").innerText = chosenMove;
}
 </script>

///aiVsAiFifty.js
<script> 
/// aiVsAiFifty.js  (your original, improved with smart wait)

async function aiVsAiFifty(cycles = 50) {
  const moveLogs = document.getElementById("moveLogs");
  moveLogs.value = ""; 

  for (let i = 1; i <= cycles; i++) {
    // 1. Ensure current FEN is loaded
    loadFEN(); 
    await new Promise(resolve => setTimeout(resolve, 3000)); // UI render

    // 2. Generate best 2-ply move
    await bestMoveTwoPlies(); 
    
    // SMART WAIT: Wait for bestMoveDisplay to update â€” max 3 minutes
    const startTime = Date.now();
    const maxWait = 3 * 60 * 1000; // 3 minutes
    let lastMove = "";

    while (true) {
      const currentMove = document.getElementById("bestMoveDisplay").innerText.trim();
      if (currentMove && currentMove !== lastMove && currentMove !== "Calculating...") {
        break; // Move is ready!
      }
      if (Date.now() - startTime > maxWait) {
        console.warn(`Cycle ${i}: bestMoveTwoPlies took >3 min, proceeding anyway...`);
        break;
      }
      await new Promise(resolve => setTimeout(resolve, 500)); // check every 0.5s
      lastMove = currentMove;
    }

    // 3. Apply the move
    applyBestMove();
    
    // 4. Transfer FEN
    transferFinalFEN(); 
    
    // 5. Log
    const move = document.getElementById("bestMoveDisplay").innerText.trim();
    const newFen = document.getElementById("finalFENOutput").value.trim();
    moveLogs.value += `${i}. Move: ${move}\n    FEN: ${newFen}\n\n`;
    
    // Short pause for visibility
    await new Promise(resolve => setTimeout(resolve, 5000)); 
  }
}
 </script>

<script> 
///showfen.js
/**
 * Generates the FULL FEN string and updates BOTH the top display 
 * AND the bottom AI's primary FEN input (id="fenInput").
 * Also triggers the AI pipeline for one move automatically.
 */
function top_showPosition(nextMoveColor) { 
  // 1. Calculate FEN Ranks 
  let fenRanks = board.map(row => {
    let line = '';
    let empty = 0;
    for (let cell of row) {
      if (cell === '') {
        empty++;
      } else {
        if (empty > 0) {
          line += empty;
          empty = 0;
        }
        line += top_pieceToFEN(cell);
      }
    }
    if (empty > 0) line += empty;
    return line;
  }).join('/');
  
  // 2. Construct the full FEN string using the provided color and fixed defaults
  const color = (nextMoveColor === 'b' ? 'b' : 'w');
  const fullFEN = `${fenRanks} ${color} - - 0 1`;
  
  // 3. Update the top board's display
  document.getElementById("position").textContent = "Board Position:\n" + fullFEN;
  
  // 4. TRANSFER COMPLETE FEN TO AI's PRIMARY INPUT (id="fenInput")
  const bottomFenInput = document.getElementById("fenInput");
  if (bottomFenInput && bottomFenInput.tagName === 'TEXTAREA') {
    bottomFenInput.value = fullFEN;
  }
  
  // 5. Trigger AI oneâ€‘move pipeline automatically
  aiOneMove(fullFEN);

  return fullFEN;
}

// Guard flag
let aiPipelineRunning = false;

// AI makes one 2â€‘ply move, then stops
async function aiOneMove(fen) {
  if (!fen) {
    alert("No FEN generated!");
    return;
  }
  if (aiPipelineRunning) return;
  aiPipelineRunning = true;

  const moveLogs = document.getElementById("moveLogs");
  if (moveLogs) moveLogs.value = "";

  try {
    // 1. Load the FEN
    loadFEN();
    await wait(3000);

    // 2. Best 2â€‘ply move
    await bestMoveTwoPlies();

    // 3. Wait for bestMoveDisplay
    await waitForElement('#bestMoveDisplay', 180000);

    // 4. Apply move
    applyBestMove();
    await wait(500);

    // 5. Transfer final FEN
    transferFinalFEN();
    await wait(200);

    // 6. Log and update human board
    const move = document.getElementById("bestMoveDisplay").innerText.trim();
    const newFen = document.getElementById("finalFENOutput").value.trim();
    if (moveLogs) moveLogs.value += `AI Move: ${move}\nFEN: ${newFen}\n\n`;

    const humanInput = document.getElementById('topFenInput');
    humanInput.value = newFen;
    top_loadPosition(); // redraw top board
  } catch (e) {
    alert('AI pipeline error: ' + e.message);
  } finally {
    aiPipelineRunning = false;
  }
}

/* ---------- tiny helpers ---------- */
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

function waitForElement(selector, timeoutMs) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    const check = () => {
      const el = document.querySelector(selector);
      if (el && el.textContent.trim()) return resolve();
      if (Date.now() - start > timeoutMs) return reject(new Error('timeout'));
      requestAnimationFrame(check);
    };
    check();
  });
}




 </script>

///main.js
<script> 

///main.js
let targets = new Map();
let obstacles = [];
let friendlies = [];
let startPos = null;
let currentTurn = 'w';

function loadFEN() {
  const fen = document.getElementById("fenInput").value.trim();
  if (fen.length === 0) {
    alert("Please enter a valid FEN string.");
    return;
  }
  parseFEN(fen);
}

function parseFEN(fen) {
  targets.clear();
  obstacles = [];
  friendlies = [];
  startPos = null;

  const pieceScores = { 'Q': 9, 'R': 3.5, 'N': 3, 'B': 3, 'P': 1, 'S': 10000 };
  const rows = fen.split(' ')[0].split('/');
  const turn = fen.split(' ')[1];
  currentTurn = turn;
  const board = document.getElementById("board");
  board.innerHTML = "";

  for (let y = 0; y < 8; y++) {
    // FIX: Use insertRow() on the table element
    const row = board.insertRow(); 
    let x = 0;
    for (let char of rows[y]) {
      if (/\d/.test(char)) {
        for (let i = 0; i < parseInt(char); i++) {
          const cell = row.insertCell();
          cell.className = (x + y) % 2 === 0 ? "white" : "black";
          x++;
        }
      } else {
        const pos = `${x + 1},${8 - y}`;
        const cell = row.insertCell();
        const isBlackSquare = (x + y) % 2 !== 0;
        cell.className = isBlackSquare ? "black" : "white";
        cell.textContent = char;

        const isWhitePiece = /[A-Z]/.test(char);
        const isBlackPiece = /[a-z]/.test(char);
        const pieceType = char.toUpperCase();

        if ((turn === 'b' && isWhitePiece) || (turn === 'w' && isBlackPiece)) {
          const score = pieceScores[pieceType] || 0;
          targets.set(pos, score);
          cell.classList.add("target");
          cell.title = `Target ${pos} â†’ ${score}`;
        } else if ((turn === 'b' && isBlackPiece) || (turn === 'w' && isWhitePiece)) {
          friendlies.push({ pos, piece: pieceType });
          obstacles.push(pos);
          cell.classList.add("friendly");
          cell.title = `Friendly ${pieceType} at ${pos}`;
          if (pieceType === 'S') startPos = pos;
        }

        if ((turn === 'b' && char === 'S') || (turn === 'w' && char === 's')) {
          targets.set(pos, pieceScores['S']);
          cell.classList.add("target");
          cell.title = `ðŸŽ¯ Main Target SKT at ${pos} â†’ ${pieceScores['S']}`;
        }

        x++;
      }
    }
  }

  const lines = [];
  for (let [pos, score] of targets.entries()) {
    lines.push(`ðŸŽ¯ Target (${pos}) â†’ ${score}`);
  }
  for (let { pos } of friendlies) {
    lines.push(`ðŸ¤ Friendly (${pos})`);
  }
  for (let pos of obstacles) {
    lines.push(`â›” Obstacle (${pos})`);
  }
  document.getElementById("targets").textContent = lines.join("\n");

  const output = document.getElementById("output");
  output.value = "";

  if (startPos) {
    const [sx, sy] = startPos.split(',').map(Number);
    // FIX: This call is commented out to prevent duplicate SKT path generation.
    // generatePaths(sx, sy, 'S'); 
  }

  // This loop now correctly handles ALL friendly pieces, including 'S', exactly once.
  for (let { pos, piece } of friendlies) {
    const [x, y] = pos.split(',').map(Number);
    generatePaths(x, y, piece);
  }
}

function linearPaths(x, y, directions) {
  const onBoard = ([a, b]) => a >= 1 && a <= 8 && b >= 1 && b <= 8;
  const isObstacle = ([a, b]) => obstacles.includes(`${a},${b}`);
  const getScore = ([a, b]) => targets.get(`${a},${b}`) || 0;

  const paths = [];

  function calculateScore(path) {
    const visited = new Set();
    let score = 0;
    for (let pos of path) {
      const key = `${pos[0]},${pos[1]}`;
      if (!visited.has(key)) {
        visited.add(key);
        score += getScore(pos);
      }
    }
    return score;
  }

  for (let [dx, dy] of directions) {
    let path = [[x, y]];
    let cx = x + dx, cy = y + dy;
    while (onBoard([cx, cy]) && !isObstacle([cx, cy])) {
      path.push([cx, cy]);
      paths.push({ path: [...path], score: calculateScore(path) });
      if (targets.has(`${cx},${cy}`)) break;
      cx += dx;
      cy += dy;
    }
  }

  paths.sort((a, b) => b.score - a.score || a.path.length - b.path.length);
  return paths;
}

function generatePaths(x, y, piece) {
  const output = document.getElementById("output");
  output.value += `\nPaths for ${piece} at (${x},${y}):\n`;

  const isWhite = currentTurn === 'w';
  let paths = [];

  switch (piece) {
    case 'S': 
      paths = SktScoreObstacles(x, y);
      break;
    case 'R':
      paths = rookPaths(x, y);
      break;
    case 'B':
      paths = bishopPaths(x, y);
      break;
    case 'Q':
      paths = queenPaths(x, y);
      break;
    case 'N':
      paths = knightPaths(x, y);
      break;
    case 'P':
      paths = pawnPaths(x, y, isWhite);
      break;
    default:
      return;
  }

  if (paths.length === 0) {
    output.value += "No valid paths found.\n";
    return;
  }

  for (let item of paths) {
    const pathStr = item.path.map(p => `(${p[0]},${p[1]})`).join(" â†’ ");
    output.value += `${pathStr} | Score: ${item.score}\n`;
  }
}
 </script>

</body>
</html>
